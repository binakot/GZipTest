# :one: Первая итерация разработки

![CPU](../diagrams/GZipTest.png)

1. Запускаем приложение и указываем параметры:

* Тип операции (`compress`, `decompress`);
* Имя входного файла (например, `input.txt`);
* Имя выходного файла (например, `input.txt.gz`).

2. `GZipApplication` выполняет разбор и валидацию полученных параметров. 
Если возникает ошибка - выводим сообщение и завершаем работу. 
Иначе продолжаем обработку файла...

3. Запускаем в отдельном потоке экземпляр класса `GZipArchiver` и делегируем ему всю дальнейшую работу. 
В главном потоке отображаем индикацию работы приложения с помощью `ConsoleSpinner`.

4. `GZipArchiver` выполняет анализ входного файла и в зависимости от типа операции формирует список задач `BaseTask` для его обработки.
Для компрессии файл разбивается на блоки размером равным параметру `bufferSize` _(по умолчанию, 1024 страницы памяти или 4 МБ)_.
Для декомпрессии файл разбивается на `GZip-блоки`, у каждого из которых свой магический заголовок. [GZIP file format specification](http://www.zlib.org/rfc-gzip.html).

5. Далее сформированный список задач передается в `TaskExecutor`, 
который помещает последовательно задачи в очередь и выполняет их в пуле потоков с размером `maxThreadsCount` 
_(по умолчанию, количество процессоров)_.

6. Каждая задача при завершении работы уведомляет `TaskExecutor` через событие `event EventHandler<TaskEventArgs> TaskDone`.
На основании этого уведомления `TaskExecutor` поддерживает в работе только ограниченное число задач, а не запускает их все разом.

7. Дополнительная синхронизация инкапсулирована в команду `WriteChunkCommand`, т.к. запись в выходной файл должна быть последовательна.
Невозможно определить смещение в файле для записи заранее, т.к. размеры предудущих блоков изначально неизвестны.
Синхронизация реализована с помощью счетчика обработанных частей (chunks) файла `static volatile int _nextWriteChunk`.

8. Если приложении завершается с помощью `Crtl-C`, то `GZipApplication` вызываем метод `Abort()` у `GZipArciver`, 
который в свою очередь останавливает `TaskExecutor`, вызывая метод `Stop()`, и очищает хранилища уже обработанных частей (chunks) файлов.
Приложение прекращает работу и завершается.